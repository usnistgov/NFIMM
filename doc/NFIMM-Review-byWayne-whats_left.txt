
For object instantiation, the code sometimes uses initialization syntax ('{}'),
sometimes explicit default constructor ('()') and sometimes implicit default
constructor ('new foo;'). Consider changing to use initialization syntax or
explicit construction ('new foo(arg1, arg2)').

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
bxb DONE
History of git pushes: (26Jul23)
git cm -m "Remove src and dest image buffers and dest buffer size from Metadata paramaters and just use the static members in NFIMM class; has been tested against png and bmp dirs with 2000 images."

nfimm.{h, cpp}
---------------
MetadataParameters structs srcImg and destImg should be objects of another
type 'struct ImgMeta' or similar. However, because you don't have dimension
for dest image you'd have to handle that case. If you leave the two structs
then you should remove to commented-out code and commentary in struct destImg.
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

Implementation of ~NFIMM(), get_imgSampleRateUnits() and other functions
should be in nfimm.cpp

Functions set_srcImgSampleRateUnits() and set_destImgSampleRateUnits don't do
what the documentation says: They don't handle "inch" or "other" or random
strings.
There's also a design quirk in that s_imgBufferRead is returned by the two
versions of readImageFileIntoBuffer(). However, s_imgBufferRead is global,
so clients of readImageFileIntoBuffer() do not need that pointer to be
returned.
There are two ways to represent units in the resolution struct: units and
unitsStr; are both necessary? Also, it's not clear what resolution.units
represent; it appears to be a flag set to 1 or 0, and the comment ("single byte 
horiz and vert units") doesn't describe what the value means. 

readImageFileIntoBuffer() and writeBufferIntoImageFile should check for
I/O errors.

bxb DONE
History of git pushes: (26Jul23)
git cm -m "Move the MetadataParameters method definitions from header to cpp file. Remove the returned pointer for methods readImageFileIntoBuffer(). Updated the comment to better describe resolution units. readImageFileIntoBuffer() and writeBufferIntoImageFile now check for
I/O errors"

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

In general, instead of using strings to represent PPI, inch/meter, etc. it
would be cleaner to use enum class, but that's a significant code change.
bxb 26Jul23 - do not implement this mod
-----------------------------------------------------------------------------


Why are s_imgStreamRead, s_imgStreamWrite and other members of the NFIMM
class declared static? Do you need a single, global instance of these items?
There's a design flaw here because NFIMM references the global single instance
s_imgBufferRead. Specifically, having s_imgBufferRead as static will cause
problems if two or more instances of NFIMM exist as the destructor deletes
s_imgBufferRead.

-----------------------------------------------------------------------------
The NFIMM copy constructor has an empty implementation, It would be better
to remove the copy constructor by declaring it "= delete". Otherwise an NFIMM
object could be copied, leading to the multiple deletions of s_imgBufferRead.
However, that means that you cannot return an NFIMM object from a function.
bxb 26Jul23 - copy constructor was previously removed and checked-in to repo
-----------------------------------------------------------------------------

The better design is to have class NFIMM manage the image buffer as private
state data. Same comment for the other global variables. The image reading
functions should also be part of the class.


The function expressUINT32AsUTCyear() doesn't deal with UTC explicitly; perhaps
a better name?

Functions expressUINT32AsUTCyear(), expressTwoBytesAsUINT16, and
expressUINT32AsFourBytes() each convert a value to big-endian. What happens if
the value is already big-endian? You may want to use the standard htons() and
htonl() functions.

The comment "BMP format uses little-endian. ..." doesn't mean anything in the
context of defining expressFourBytesAsUINT32() or expressTwoBytesAsUINT16().


---------------------------------------------------------------------------


FileHeader( BMP * );
Is it expected that the FileHeader function will modify the BMP object? If
not, you may consider using const pointer to const for BMP*.
bxb 26Jul23 - changing to FileHeader( const BMP * ); in bmp.h and the definition
in fileheader.cpp WOULD NOT COMPILE. Therefore, did not attempt the same for
InfoHeader( BMP * ); .

There's a design issue: The BMP constructor takes a pointer to a
MetadataParameters object and stores it in the BMP object's state. Later
a buffer is allocated off of the _params pointer. You have shared ownership
of the MetadataParameters object: The caller of the BMP constructor and the
BMP object itself. The responsibility of freeing MetadataParameters and
MetadataParameters::destImg::buffer is muddled. The use of a smart pointer to
wrap destImg.buffer could help but the MetadataParameters object's lifetime
is not well defined.


---------------------------------------------------------------------------

I recommend that you use smart pointers for allocating objects fileHeader,
infoHeader.
bxb DONE  (07Jul2023)

History of git pushes:
git cm -m "Use smart pointers for allocating objects fileHeader, infoHeader in function BMP::modify(); removed all associated references; was tested against 2000 source images; see config file config_win_bmp__pub_release__2000test.ini"
---------------------------------------------------------------------------

Modern C++ favors the use of std::vector(uint8_t) over allocating arrays
dynamically. This removes the need to delete[] the buffer. (You can use
std::unique_ptr<> instead but that is less fashionable).


---------------------------------------------------------------------------
BMP::r_cursor and BMP::w_cursor are initialized to 0 but afterwards it's not
clear how to reset those values. The comment for BMP::nextLengthBytes states
that r_cursor is initially set by the caller but that doesn't appear to be the
case. It would be a bad design to have the client of BMP:: functions need to
manipulate r_cursor and w_cursor. I suggest that you state that the design of
the BMP class is one that sets the buffer parsing to the start of the buffer
and all reads move the index into the buffer. If you want to provide the
ability to 'rewind' or 'fast-forward' then add functions to move the cursors.

I realize you may not want to change the BMP design as the function that
use the cursors are private, so the class is not meant to be used in a generic
BMP parsing sense. I would then suggest that you remove comments regarding
the cursors from the functions that manipulate them.

---------------------------------------------------------------------------

file_header.cpp
---------------
The @return comment for the read() function don't apply to that function.
In addition, the comments for read() do not describe what the function does.

---------------------------------------------------------------------------
---------------------------------------------------------------------------



png.{h, cpp}
phys.cpp
signature.cpp
----------
PNG::IhdrX has the same problem as mentioned above: Shared state data, the
png pointer in this case.
The declaration of _srcChunkPointers[1000] and _insertChunkPointers[10] seems
arbitrary; do the values 1000 and 10 mean anything? Are we guaranteed to never
run off the end of the array?

Classes Signature, IhdrX, Phys and Text appear to be essentially a set of
helper functions to parse PNG buffers. There is a strong coupling between
those classes and class PNG, making it hard to understand what the code is
modifying. Consider making those class functions part of the PNG class.
(The Signature class doesn't modify the PNG buffers as that code is
commented out).

I realize this would be a large change, and some state data is maintained in
those classes (Text::_countChunk for example), but it would be a better
design have have the PNG class manage its own data instead of using friend
classes to reach in and modify, thereby needing to know the implementation
details of PNG.

Line 200 of png.cpp allocates an object with 'new ChunkLayout'; It is better
to use 'new ChunkLayout()'.
ChunkLayout objects are allocated (png.cpp::parseAllChunks) A comment states
"With each chunk, save the pointer to the ChunkLayout object in an array." and
see that code (png.cpp:231) doing that.  However, it is not clear when the
currentChunk object (and objects it points to) are free'd.  The PNG::modify()
does delete[] but tracing the call to modify() is not easily done. In addition,
the objects pointed to by the ChunkLayout object are not all allocated within
a single code block. In particular, ChunkLayout::wholeChunkBuffer is allocated
within concat() which is defined in png.h. 

---------------------------------------------------------------------------

---------------------------------------------------------------------------
ihdr.cpp
---------
The comment for parseChunk() states "none of its bytes are modified" which is
true (_srcChunkPointers elements are not modifed) but other fields within the
friendly fields of the png object are.

---------------------------------------------------------------------------
text.cpp
---------
Objects tchunk and tchunk->dataBuffer are not deleted in many of the error
paths. In the non-error path these objects must be deleted by methods in the
PNG class. This design creates a strong coupling between the Text and PNG
classes which would be hard to maintain. As mentioned above, can the functions
in the Text class be made members of the PNG class?

There is commented-out code (lines 139-140 for example) that should be
explained as to why that code is worth keeping.

On line 220 'cat' is allocated but never deleted. This occurs inside a loop so
multiple leaks are possible.
